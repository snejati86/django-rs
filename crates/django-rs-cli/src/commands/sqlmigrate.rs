//! The `sqlmigrate` management command.
//!
//! Shows the SQL that would be executed for a specific migration.
//! This mirrors Django's `sqlmigrate` command.

use async_trait::async_trait;
use django_rs_core::{DjangoError, Settings};

use crate::command::ManagementCommand;

/// Displays the SQL for a specific migration.
///
/// Takes an app label and migration name, loads the migration file,
/// and prints the SQL statements that would be executed. Supports
/// `--backwards` to show the reverse SQL.
pub struct SqlmigrateCommand;

/// Generates SQL statements for a migration's operations.
///
/// In a full implementation, this would load the migration file and use the
/// schema editor to produce SQL. For now, it generates a placeholder comment.
pub fn generate_migration_sql(
    app_label: &str,
    migration_name: &str,
    backwards: bool,
) -> Vec<String> {
    let direction = if backwards { "reverse" } else { "forward" };
    vec![
        format!("-- SQL for {direction} migration {app_label}.{migration_name}"),
        format!("-- (In a full implementation, this would contain actual SQL statements)"),
        format!("-- Generated by django-rs sqlmigrate for {app_label}/{migration_name}"),
    ]
}

#[async_trait]
impl ManagementCommand for SqlmigrateCommand {
    fn name(&self) -> &'static str {
        "sqlmigrate"
    }

    fn help(&self) -> &'static str {
        "Show SQL for a specific migration"
    }

    fn add_arguments(&self, cmd: clap::Command) -> clap::Command {
        cmd.arg(
            clap::Arg::new("app_label")
                .help("App label of the migration")
                .required(true),
        )
        .arg(
            clap::Arg::new("migration_name")
                .help("Migration name (e.g. 0001_initial)")
                .required(true),
        )
        .arg(
            clap::Arg::new("backwards")
                .long("backwards")
                .action(clap::ArgAction::SetTrue)
                .help("Show the SQL for reversing the migration"),
        )
        .arg(
            clap::Arg::new("database")
                .long("database")
                .default_value("default")
                .help("Database alias"),
        )
    }

    async fn handle(
        &self,
        matches: &clap::ArgMatches,
        _settings: &Settings,
    ) -> Result<(), DjangoError> {
        let app_label = matches
            .get_one::<String>("app_label")
            .ok_or_else(|| DjangoError::ConfigurationError("app_label is required".to_string()))?;
        let migration_name = matches.get_one::<String>("migration_name").ok_or_else(|| {
            DjangoError::ConfigurationError("migration_name is required".to_string())
        })?;
        let backwards = matches.get_flag("backwards");

        let sql_statements = generate_migration_sql(app_label, migration_name, backwards);

        for stmt in &sql_statements {
            tracing::info!("{stmt}");
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_migration_sql_forward() {
        let stmts = generate_migration_sql("blog", "0001_initial", false);
        assert!(!stmts.is_empty());
        assert!(stmts[0].contains("forward"));
        assert!(stmts[0].contains("blog"));
        assert!(stmts[0].contains("0001_initial"));
    }

    #[test]
    fn test_generate_migration_sql_backwards() {
        let stmts = generate_migration_sql("blog", "0001_initial", true);
        assert!(!stmts.is_empty());
        assert!(stmts[0].contains("reverse"));
    }

    #[test]
    fn test_command_metadata() {
        let cmd = SqlmigrateCommand;
        assert_eq!(cmd.name(), "sqlmigrate");
        assert_eq!(cmd.help(), "Show SQL for a specific migration");
    }

    #[tokio::test]
    async fn test_sqlmigrate_handle() {
        let cmd = SqlmigrateCommand;
        let cli = clap::Command::new("test")
            .subcommand(cmd.add_arguments(clap::Command::new("sqlmigrate")));
        let matches = cli
            .try_get_matches_from(["test", "sqlmigrate", "blog", "0001_initial"])
            .unwrap();
        let (_, sub_matches) = matches.subcommand().unwrap();

        let settings = Settings::default();
        let result = cmd.handle(sub_matches, &settings).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_sqlmigrate_backwards() {
        let cmd = SqlmigrateCommand;
        let cli = clap::Command::new("test")
            .subcommand(cmd.add_arguments(clap::Command::new("sqlmigrate")));
        let matches = cli
            .try_get_matches_from(["test", "sqlmigrate", "blog", "0001_initial", "--backwards"])
            .unwrap();
        let (_, sub_matches) = matches.subcommand().unwrap();

        let settings = Settings::default();
        let result = cmd.handle(sub_matches, &settings).await;
        assert!(result.is_ok());
    }
}
